//
// This file was generated by the JavaTM Architecture for XML Binding(JAXB) Reference Implementation, vJAXB 2.1.3 in JDK 1.6 
// See <a href="http://java.sun.com/xml/jaxb">http://java.sun.com/xml/jaxb</a> 
// Any modifications to this file will be lost upon recompilation of the source schema. 
// Generated on: 2008.09.22 at 04:04:36 PM CEST 
//


package org.gpx2web.binding.kml.impl;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlAnyAttribute;
import javax.xml.bind.annotation.XmlAnyElement;
import javax.xml.bind.annotation.XmlAttribute;
import javax.xml.bind.annotation.XmlElement;
import javax.xml.bind.annotation.XmlRootElement;
import javax.xml.bind.annotation.XmlSchemaType;
import javax.xml.bind.annotation.XmlType;
import javax.xml.bind.annotation.XmlValue;
import javax.xml.namespace.QName;
import org.gpx2web.binding.kml.AddressDetails;
import org.gpx2web.binding.kml.AddressLine;
import org.gpx2web.binding.kml.AddressLinesType;
import org.gpx2web.binding.kml.AdministrativeArea;
import org.gpx2web.binding.kml.CountryName;
import org.gpx2web.binding.kml.Locality;
import org.gpx2web.binding.kml.Thoroughfare;

@XmlAccessorType(XmlAccessType.FIELD)
@XmlType(name = "AddressDetails", namespace = "urn:oasis:names:tc:ciq:xsdschema:xAL:2.0", propOrder = {
    "postalServiceElements",
    "thoroughfare",
    "locality",
    "administrativeArea",
    "country",
    "addressLines",
    "address",
    "anies"
})
@XmlRootElement(name = "AddressDetails", namespace = "urn:oasis:names:tc:ciq:xsdschema:xAL:2.0")
public class AddressDetailsImpl
    implements AddressDetails
{

    @XmlElement(name = "PostalServiceElements", namespace = "urn:oasis:names:tc:ciq:xsdschema:xAL:2.0", type = AddressDetailsImpl.PostalServiceElementsImpl.class)
    protected AddressDetailsImpl.PostalServiceElementsImpl postalServiceElements;
    @XmlElement(name = "Thoroughfare", namespace = "urn:oasis:names:tc:ciq:xsdschema:xAL:2.0", type = ThoroughfareImpl.class)
    protected ThoroughfareImpl thoroughfare;
    @XmlElement(name = "Locality", namespace = "urn:oasis:names:tc:ciq:xsdschema:xAL:2.0", type = LocalityImpl.class)
    protected LocalityImpl locality;
    @XmlElement(name = "AdministrativeArea", namespace = "urn:oasis:names:tc:ciq:xsdschema:xAL:2.0", type = AdministrativeAreaImpl.class)
    protected AdministrativeAreaImpl administrativeArea;
    @XmlElement(name = "Country", namespace = "urn:oasis:names:tc:ciq:xsdschema:xAL:2.0", type = AddressDetailsImpl.CountryImpl.class)
    protected AddressDetailsImpl.CountryImpl country;
    @XmlElement(name = "AddressLines", namespace = "urn:oasis:names:tc:ciq:xsdschema:xAL:2.0", type = AddressLinesTypeImpl.class)
    protected AddressLinesTypeImpl addressLines;
    @XmlElement(name = "Address", namespace = "urn:oasis:names:tc:ciq:xsdschema:xAL:2.0", type = AddressDetailsImpl.AddressImpl.class)
    protected AddressDetailsImpl.AddressImpl address;
    @XmlAnyElement(lax = true)
    protected List<Object> anies;
    @XmlAttribute(name = "AddressType")
    @XmlSchemaType(name = "anySimpleType")
    protected String addressType;
    @XmlAttribute(name = "CurrentStatus")
    @XmlSchemaType(name = "anySimpleType")
    protected String currentStatus;
    @XmlAttribute(name = "ValidFromDate")
    @XmlSchemaType(name = "anySimpleType")
    protected String validFromDate;
    @XmlAttribute(name = "ValidToDate")
    @XmlSchemaType(name = "anySimpleType")
    protected String validToDate;
    @XmlAttribute(name = "Usage")
    @XmlSchemaType(name = "anySimpleType")
    protected String usage;
    @XmlAttribute(name = "AddressDetailsKey")
    @XmlSchemaType(name = "anySimpleType")
    protected String addressDetailsKey;
    @XmlAttribute(name = "Code")
    @XmlSchemaType(name = "anySimpleType")
    protected String code;
    @XmlAnyAttribute
    private Map<QName, String> otherAttributes = new HashMap<QName, String>();

    public AddressDetails.PostalServiceElements getPostalServiceElements() {
        return postalServiceElements;
    }

    public void setPostalServiceElements(AddressDetails.PostalServiceElements value) {
        this.postalServiceElements = ((AddressDetailsImpl.PostalServiceElementsImpl) value);
    }

    public Thoroughfare getThoroughfare() {
        return thoroughfare;
    }

    public void setThoroughfare(Thoroughfare value) {
        this.thoroughfare = ((ThoroughfareImpl) value);
    }

    public Locality getLocality() {
        return locality;
    }

    public void setLocality(Locality value) {
        this.locality = ((LocalityImpl) value);
    }

    public AdministrativeArea getAdministrativeArea() {
        return administrativeArea;
    }

    public void setAdministrativeArea(AdministrativeArea value) {
        this.administrativeArea = ((AdministrativeAreaImpl) value);
    }

    public AddressDetails.Country getCountry() {
        return country;
    }

    public void setCountry(AddressDetails.Country value) {
        this.country = ((AddressDetailsImpl.CountryImpl) value);
    }

    public AddressLinesType getAddressLines() {
        return addressLines;
    }

    public void setAddressLines(AddressLinesType value) {
        this.addressLines = ((AddressLinesTypeImpl) value);
    }

    public AddressDetails.Address getAddress() {
        return address;
    }

    public void setAddress(AddressDetails.Address value) {
        this.address = ((AddressDetailsImpl.AddressImpl) value);
    }

    public List<Object> getAnies() {
        if (anies == null) {
            anies = new ArrayList<Object>();
        }
        return this.anies;
    }

    public String getAddressType() {
        return addressType;
    }

    public void setAddressType(String value) {
        this.addressType = value;
    }

    public String getCurrentStatus() {
        return currentStatus;
    }

    public void setCurrentStatus(String value) {
        this.currentStatus = value;
    }

    public String getValidFromDate() {
        return validFromDate;
    }

    public void setValidFromDate(String value) {
        this.validFromDate = value;
    }

    public String getValidToDate() {
        return validToDate;
    }

    public void setValidToDate(String value) {
        this.validToDate = value;
    }

    public String getUsage() {
        return usage;
    }

    public void setUsage(String value) {
        this.usage = value;
    }

    public String getAddressDetailsKey() {
        return addressDetailsKey;
    }

    public void setAddressDetailsKey(String value) {
        this.addressDetailsKey = value;
    }

    public String getCode() {
        return code;
    }

    public void setCode(String value) {
        this.code = value;
    }

    /**
     * Gets a map that contains attributes that aren't bound to any typed property on this class.
     * 
     * <p>
     * the map is keyed by the name of the attribute and 
     * the value is the string value of the attribute.
     * 
     * the map returned by this method is live, and you can add new attribute
     * by updating the map directly. Because of this design, there's no setter.
     * 
     * 
     * @return
     *     always non-null
     */
    public Map<QName, String> getOtherAttributes() {
        return otherAttributes;
    }

    @XmlAccessorType(XmlAccessType.FIELD)
    @XmlType(name = "", propOrder = {
        "content"
    })
    public static class AddressImpl
        implements AddressDetails.Address
    {

        @XmlValue
        protected String content;
        @XmlAttribute(name = "Type")
        @XmlSchemaType(name = "anySimpleType")
        protected String type;
        @XmlAttribute(name = "Code")
        @XmlSchemaType(name = "anySimpleType")
        protected String code;
        @XmlAnyAttribute
        private Map<QName, String> otherAttributes = new HashMap<QName, String>();

        public String getContent() {
            return content;
        }

        public void setContent(String value) {
            this.content = value;
        }

        public String getType() {
            return type;
        }

        public void setType(String value) {
            this.type = value;
        }

        public String getCode() {
            return code;
        }

        public void setCode(String value) {
            this.code = value;
        }

        /**
         * Gets a map that contains attributes that aren't bound to any typed property on this class.
         * 
         * <p>
         * the map is keyed by the name of the attribute and 
         * the value is the string value of the attribute.
         * 
         * the map returned by this method is live, and you can add new attribute
         * by updating the map directly. Because of this design, there's no setter.
         * 
         * 
         * @return
         *     always non-null
         */
        public Map<QName, String> getOtherAttributes() {
            return otherAttributes;
        }

    }

    @XmlAccessorType(XmlAccessType.FIELD)
    @XmlType(name = "", propOrder = {
        "addressLines",
        "countryNameCodes",
        "countryNames",
        "thoroughfare",
        "locality",
        "administrativeArea",
        "anies"
    })
    public static class CountryImpl
        implements AddressDetails.Country
    {

        @XmlElement(name = "AddressLine", namespace = "urn:oasis:names:tc:ciq:xsdschema:xAL:2.0", type = AddressLineImpl.class)
        protected List<AddressLine> addressLines;
        @XmlElement(name = "CountryNameCode", namespace = "urn:oasis:names:tc:ciq:xsdschema:xAL:2.0", type = AddressDetailsImpl.CountryImpl.CountryNameCodeImpl.class)
        protected List<AddressDetails.Country.CountryNameCode> countryNameCodes;
        @XmlElement(name = "CountryName", namespace = "urn:oasis:names:tc:ciq:xsdschema:xAL:2.0", type = CountryNameImpl.class)
        protected List<CountryName> countryNames;
        @XmlElement(name = "Thoroughfare", namespace = "urn:oasis:names:tc:ciq:xsdschema:xAL:2.0", type = ThoroughfareImpl.class)
        protected ThoroughfareImpl thoroughfare;
        @XmlElement(name = "Locality", namespace = "urn:oasis:names:tc:ciq:xsdschema:xAL:2.0", type = LocalityImpl.class)
        protected LocalityImpl locality;
        @XmlElement(name = "AdministrativeArea", namespace = "urn:oasis:names:tc:ciq:xsdschema:xAL:2.0", type = AdministrativeAreaImpl.class)
        protected AdministrativeAreaImpl administrativeArea;
        @XmlAnyElement(lax = true)
        protected List<Object> anies;
        @XmlAnyAttribute
        private Map<QName, String> otherAttributes = new HashMap<QName, String>();

        public List<AddressLine> getAddressLines() {
            if (addressLines == null) {
                addressLines = new ArrayList<AddressLine>();
            }
            return this.addressLines;
        }

        public List<AddressDetails.Country.CountryNameCode> getCountryNameCodes() {
            if (countryNameCodes == null) {
                countryNameCodes = new ArrayList<AddressDetails.Country.CountryNameCode>();
            }
            return this.countryNameCodes;
        }

        public List<CountryName> getCountryNames() {
            if (countryNames == null) {
                countryNames = new ArrayList<CountryName>();
            }
            return this.countryNames;
        }

        public Thoroughfare getThoroughfare() {
            return thoroughfare;
        }

        public void setThoroughfare(Thoroughfare value) {
            this.thoroughfare = ((ThoroughfareImpl) value);
        }

        public Locality getLocality() {
            return locality;
        }

        public void setLocality(Locality value) {
            this.locality = ((LocalityImpl) value);
        }

        public AdministrativeArea getAdministrativeArea() {
            return administrativeArea;
        }

        public void setAdministrativeArea(AdministrativeArea value) {
            this.administrativeArea = ((AdministrativeAreaImpl) value);
        }

        public List<Object> getAnies() {
            if (anies == null) {
                anies = new ArrayList<Object>();
            }
            return this.anies;
        }

        /**
         * Gets a map that contains attributes that aren't bound to any typed property on this class.
         * 
         * <p>
         * the map is keyed by the name of the attribute and 
         * the value is the string value of the attribute.
         * 
         * the map returned by this method is live, and you can add new attribute
         * by updating the map directly. Because of this design, there's no setter.
         * 
         * 
         * @return
         *     always non-null
         */
        public Map<QName, String> getOtherAttributes() {
            return otherAttributes;
        }

        @XmlAccessorType(XmlAccessType.FIELD)
        @XmlType(name = "", propOrder = {
            "content"
        })
        public static class CountryNameCodeImpl
            implements AddressDetails.Country.CountryNameCode
        {

            @XmlValue
            protected String content;
            @XmlAttribute(name = "Scheme")
            @XmlSchemaType(name = "anySimpleType")
            protected String scheme;
            @XmlAttribute(name = "Code")
            @XmlSchemaType(name = "anySimpleType")
            protected String code;
            @XmlAnyAttribute
            private Map<QName, String> otherAttributes = new HashMap<QName, String>();

            public String getContent() {
                return content;
            }

            public void setContent(String value) {
                this.content = value;
            }

            public String getScheme() {
                return scheme;
            }

            public void setScheme(String value) {
                this.scheme = value;
            }

            public String getCode() {
                return code;
            }

            public void setCode(String value) {
                this.code = value;
            }

            /**
             * Gets a map that contains attributes that aren't bound to any typed property on this class.
             * 
             * <p>
             * the map is keyed by the name of the attribute and 
             * the value is the string value of the attribute.
             * 
             * the map returned by this method is live, and you can add new attribute
             * by updating the map directly. Because of this design, there's no setter.
             * 
             * 
             * @return
             *     always non-null
             */
            public Map<QName, String> getOtherAttributes() {
                return otherAttributes;
            }

        }

    }

    @XmlAccessorType(XmlAccessType.FIELD)
    @XmlType(name = "", propOrder = {
        "addressIdentifiers",
        "endorsementLineCode",
        "keyLineCode",
        "barcode",
        "sortingCode",
        "addressLatitude",
        "addressLatitudeDirection",
        "addressLongitude",
        "addressLongitudeDirection",
        "supplementaryPostalServiceDatas",
        "anies"
    })
    public static class PostalServiceElementsImpl
        implements AddressDetails.PostalServiceElements
    {

        @XmlElement(name = "AddressIdentifier", namespace = "urn:oasis:names:tc:ciq:xsdschema:xAL:2.0", type = AddressDetailsImpl.PostalServiceElementsImpl.AddressIdentifierImpl.class)
        protected List<AddressDetails.PostalServiceElements.AddressIdentifier> addressIdentifiers;
        @XmlElement(name = "EndorsementLineCode", namespace = "urn:oasis:names:tc:ciq:xsdschema:xAL:2.0", type = AddressDetailsImpl.PostalServiceElementsImpl.EndorsementLineCodeImpl.class)
        protected AddressDetailsImpl.PostalServiceElementsImpl.EndorsementLineCodeImpl endorsementLineCode;
        @XmlElement(name = "KeyLineCode", namespace = "urn:oasis:names:tc:ciq:xsdschema:xAL:2.0", type = AddressDetailsImpl.PostalServiceElementsImpl.KeyLineCodeImpl.class)
        protected AddressDetailsImpl.PostalServiceElementsImpl.KeyLineCodeImpl keyLineCode;
        @XmlElement(name = "Barcode", namespace = "urn:oasis:names:tc:ciq:xsdschema:xAL:2.0", type = AddressDetailsImpl.PostalServiceElementsImpl.BarcodeImpl.class)
        protected AddressDetailsImpl.PostalServiceElementsImpl.BarcodeImpl barcode;
        @XmlElement(name = "SortingCode", namespace = "urn:oasis:names:tc:ciq:xsdschema:xAL:2.0", type = AddressDetailsImpl.PostalServiceElementsImpl.SortingCodeImpl.class)
        protected AddressDetailsImpl.PostalServiceElementsImpl.SortingCodeImpl sortingCode;
        @XmlElement(name = "AddressLatitude", namespace = "urn:oasis:names:tc:ciq:xsdschema:xAL:2.0", type = AddressDetailsImpl.PostalServiceElementsImpl.AddressLatitudeImpl.class)
        protected AddressDetailsImpl.PostalServiceElementsImpl.AddressLatitudeImpl addressLatitude;
        @XmlElement(name = "AddressLatitudeDirection", namespace = "urn:oasis:names:tc:ciq:xsdschema:xAL:2.0", type = AddressDetailsImpl.PostalServiceElementsImpl.AddressLatitudeDirectionImpl.class)
        protected AddressDetailsImpl.PostalServiceElementsImpl.AddressLatitudeDirectionImpl addressLatitudeDirection;
        @XmlElement(name = "AddressLongitude", namespace = "urn:oasis:names:tc:ciq:xsdschema:xAL:2.0", type = AddressDetailsImpl.PostalServiceElementsImpl.AddressLongitudeImpl.class)
        protected AddressDetailsImpl.PostalServiceElementsImpl.AddressLongitudeImpl addressLongitude;
        @XmlElement(name = "AddressLongitudeDirection", namespace = "urn:oasis:names:tc:ciq:xsdschema:xAL:2.0", type = AddressDetailsImpl.PostalServiceElementsImpl.AddressLongitudeDirectionImpl.class)
        protected AddressDetailsImpl.PostalServiceElementsImpl.AddressLongitudeDirectionImpl addressLongitudeDirection;
        @XmlElement(name = "SupplementaryPostalServiceData", namespace = "urn:oasis:names:tc:ciq:xsdschema:xAL:2.0", type = AddressDetailsImpl.PostalServiceElementsImpl.SupplementaryPostalServiceDataImpl.class)
        protected List<AddressDetails.PostalServiceElements.SupplementaryPostalServiceData> supplementaryPostalServiceDatas;
        @XmlAnyElement(lax = true)
        protected List<Object> anies;
        @XmlAttribute(name = "Type")
        @XmlSchemaType(name = "anySimpleType")
        protected String type;
        @XmlAnyAttribute
        private Map<QName, String> otherAttributes = new HashMap<QName, String>();

        public List<AddressDetails.PostalServiceElements.AddressIdentifier> getAddressIdentifiers() {
            if (addressIdentifiers == null) {
                addressIdentifiers = new ArrayList<AddressDetails.PostalServiceElements.AddressIdentifier>();
            }
            return this.addressIdentifiers;
        }

        public AddressDetails.PostalServiceElements.EndorsementLineCode getEndorsementLineCode() {
            return endorsementLineCode;
        }

        public void setEndorsementLineCode(AddressDetails.PostalServiceElements.EndorsementLineCode value) {
            this.endorsementLineCode = ((AddressDetailsImpl.PostalServiceElementsImpl.EndorsementLineCodeImpl) value);
        }

        public AddressDetails.PostalServiceElements.KeyLineCode getKeyLineCode() {
            return keyLineCode;
        }

        public void setKeyLineCode(AddressDetails.PostalServiceElements.KeyLineCode value) {
            this.keyLineCode = ((AddressDetailsImpl.PostalServiceElementsImpl.KeyLineCodeImpl) value);
        }

        public AddressDetails.PostalServiceElements.Barcode getBarcode() {
            return barcode;
        }

        public void setBarcode(AddressDetails.PostalServiceElements.Barcode value) {
            this.barcode = ((AddressDetailsImpl.PostalServiceElementsImpl.BarcodeImpl) value);
        }

        public AddressDetails.PostalServiceElements.SortingCode getSortingCode() {
            return sortingCode;
        }

        public void setSortingCode(AddressDetails.PostalServiceElements.SortingCode value) {
            this.sortingCode = ((AddressDetailsImpl.PostalServiceElementsImpl.SortingCodeImpl) value);
        }

        public AddressDetails.PostalServiceElements.AddressLatitude getAddressLatitude() {
            return addressLatitude;
        }

        public void setAddressLatitude(AddressDetails.PostalServiceElements.AddressLatitude value) {
            this.addressLatitude = ((AddressDetailsImpl.PostalServiceElementsImpl.AddressLatitudeImpl) value);
        }

        public AddressDetails.PostalServiceElements.AddressLatitudeDirection getAddressLatitudeDirection() {
            return addressLatitudeDirection;
        }

        public void setAddressLatitudeDirection(AddressDetails.PostalServiceElements.AddressLatitudeDirection value) {
            this.addressLatitudeDirection = ((AddressDetailsImpl.PostalServiceElementsImpl.AddressLatitudeDirectionImpl) value);
        }

        public AddressDetails.PostalServiceElements.AddressLongitude getAddressLongitude() {
            return addressLongitude;
        }

        public void setAddressLongitude(AddressDetails.PostalServiceElements.AddressLongitude value) {
            this.addressLongitude = ((AddressDetailsImpl.PostalServiceElementsImpl.AddressLongitudeImpl) value);
        }

        public AddressDetails.PostalServiceElements.AddressLongitudeDirection getAddressLongitudeDirection() {
            return addressLongitudeDirection;
        }

        public void setAddressLongitudeDirection(AddressDetails.PostalServiceElements.AddressLongitudeDirection value) {
            this.addressLongitudeDirection = ((AddressDetailsImpl.PostalServiceElementsImpl.AddressLongitudeDirectionImpl) value);
        }

        public List<AddressDetails.PostalServiceElements.SupplementaryPostalServiceData> getSupplementaryPostalServiceDatas() {
            if (supplementaryPostalServiceDatas == null) {
                supplementaryPostalServiceDatas = new ArrayList<AddressDetails.PostalServiceElements.SupplementaryPostalServiceData>();
            }
            return this.supplementaryPostalServiceDatas;
        }

        public List<Object> getAnies() {
            if (anies == null) {
                anies = new ArrayList<Object>();
            }
            return this.anies;
        }

        public String getType() {
            return type;
        }

        public void setType(String value) {
            this.type = value;
        }

        /**
         * Gets a map that contains attributes that aren't bound to any typed property on this class.
         * 
         * <p>
         * the map is keyed by the name of the attribute and 
         * the value is the string value of the attribute.
         * 
         * the map returned by this method is live, and you can add new attribute
         * by updating the map directly. Because of this design, there's no setter.
         * 
         * 
         * @return
         *     always non-null
         */
        public Map<QName, String> getOtherAttributes() {
            return otherAttributes;
        }

        @XmlAccessorType(XmlAccessType.FIELD)
        @XmlType(name = "", propOrder = {
            "content"
        })
        public static class AddressIdentifierImpl
            implements AddressDetails.PostalServiceElements.AddressIdentifier
        {

            @XmlValue
            protected String content;
            @XmlAttribute(name = "IdentifierType")
            @XmlSchemaType(name = "anySimpleType")
            protected String identifierType;
            @XmlAttribute(name = "Type")
            @XmlSchemaType(name = "anySimpleType")
            protected String type;
            @XmlAttribute(name = "Code")
            @XmlSchemaType(name = "anySimpleType")
            protected String code;
            @XmlAnyAttribute
            private Map<QName, String> otherAttributes = new HashMap<QName, String>();

            public String getContent() {
                return content;
            }

            public void setContent(String value) {
                this.content = value;
            }

            public String getIdentifierType() {
                return identifierType;
            }

            public void setIdentifierType(String value) {
                this.identifierType = value;
            }

            public String getType() {
                return type;
            }

            public void setType(String value) {
                this.type = value;
            }

            public String getCode() {
                return code;
            }

            public void setCode(String value) {
                this.code = value;
            }

            /**
             * Gets a map that contains attributes that aren't bound to any typed property on this class.
             * 
             * <p>
             * the map is keyed by the name of the attribute and 
             * the value is the string value of the attribute.
             * 
             * the map returned by this method is live, and you can add new attribute
             * by updating the map directly. Because of this design, there's no setter.
             * 
             * 
             * @return
             *     always non-null
             */
            public Map<QName, String> getOtherAttributes() {
                return otherAttributes;
            }

        }

        @XmlAccessorType(XmlAccessType.FIELD)
        @XmlType(name = "", propOrder = {
            "content"
        })
        public static class AddressLatitudeDirectionImpl
            implements AddressDetails.PostalServiceElements.AddressLatitudeDirection
        {

            @XmlValue
            protected String content;
            @XmlAttribute(name = "Type")
            @XmlSchemaType(name = "anySimpleType")
            protected String type;
            @XmlAttribute(name = "Code")
            @XmlSchemaType(name = "anySimpleType")
            protected String code;
            @XmlAnyAttribute
            private Map<QName, String> otherAttributes = new HashMap<QName, String>();

            public String getContent() {
                return content;
            }

            public void setContent(String value) {
                this.content = value;
            }

            public String getType() {
                return type;
            }

            public void setType(String value) {
                this.type = value;
            }

            public String getCode() {
                return code;
            }

            public void setCode(String value) {
                this.code = value;
            }

            /**
             * Gets a map that contains attributes that aren't bound to any typed property on this class.
             * 
             * <p>
             * the map is keyed by the name of the attribute and 
             * the value is the string value of the attribute.
             * 
             * the map returned by this method is live, and you can add new attribute
             * by updating the map directly. Because of this design, there's no setter.
             * 
             * 
             * @return
             *     always non-null
             */
            public Map<QName, String> getOtherAttributes() {
                return otherAttributes;
            }

        }

        @XmlAccessorType(XmlAccessType.FIELD)
        @XmlType(name = "", propOrder = {
            "content"
        })
        public static class AddressLatitudeImpl
            implements AddressDetails.PostalServiceElements.AddressLatitude
        {

            @XmlValue
            protected String content;
            @XmlAttribute(name = "Type")
            @XmlSchemaType(name = "anySimpleType")
            protected String type;
            @XmlAttribute(name = "Code")
            @XmlSchemaType(name = "anySimpleType")
            protected String code;
            @XmlAnyAttribute
            private Map<QName, String> otherAttributes = new HashMap<QName, String>();

            public String getContent() {
                return content;
            }

            public void setContent(String value) {
                this.content = value;
            }

            public String getType() {
                return type;
            }

            public void setType(String value) {
                this.type = value;
            }

            public String getCode() {
                return code;
            }

            public void setCode(String value) {
                this.code = value;
            }

            /**
             * Gets a map that contains attributes that aren't bound to any typed property on this class.
             * 
             * <p>
             * the map is keyed by the name of the attribute and 
             * the value is the string value of the attribute.
             * 
             * the map returned by this method is live, and you can add new attribute
             * by updating the map directly. Because of this design, there's no setter.
             * 
             * 
             * @return
             *     always non-null
             */
            public Map<QName, String> getOtherAttributes() {
                return otherAttributes;
            }

        }

        @XmlAccessorType(XmlAccessType.FIELD)
        @XmlType(name = "", propOrder = {
            "content"
        })
        public static class AddressLongitudeDirectionImpl
            implements AddressDetails.PostalServiceElements.AddressLongitudeDirection
        {

            @XmlValue
            protected String content;
            @XmlAttribute(name = "Type")
            @XmlSchemaType(name = "anySimpleType")
            protected String type;
            @XmlAttribute(name = "Code")
            @XmlSchemaType(name = "anySimpleType")
            protected String code;
            @XmlAnyAttribute
            private Map<QName, String> otherAttributes = new HashMap<QName, String>();

            public String getContent() {
                return content;
            }

            public void setContent(String value) {
                this.content = value;
            }

            public String getType() {
                return type;
            }

            public void setType(String value) {
                this.type = value;
            }

            public String getCode() {
                return code;
            }

            public void setCode(String value) {
                this.code = value;
            }

            /**
             * Gets a map that contains attributes that aren't bound to any typed property on this class.
             * 
             * <p>
             * the map is keyed by the name of the attribute and 
             * the value is the string value of the attribute.
             * 
             * the map returned by this method is live, and you can add new attribute
             * by updating the map directly. Because of this design, there's no setter.
             * 
             * 
             * @return
             *     always non-null
             */
            public Map<QName, String> getOtherAttributes() {
                return otherAttributes;
            }

        }

        @XmlAccessorType(XmlAccessType.FIELD)
        @XmlType(name = "", propOrder = {
            "content"
        })
        public static class AddressLongitudeImpl
            implements AddressDetails.PostalServiceElements.AddressLongitude
        {

            @XmlValue
            protected String content;
            @XmlAttribute(name = "Type")
            @XmlSchemaType(name = "anySimpleType")
            protected String type;
            @XmlAttribute(name = "Code")
            @XmlSchemaType(name = "anySimpleType")
            protected String code;
            @XmlAnyAttribute
            private Map<QName, String> otherAttributes = new HashMap<QName, String>();

            public String getContent() {
                return content;
            }

            public void setContent(String value) {
                this.content = value;
            }

            public String getType() {
                return type;
            }

            public void setType(String value) {
                this.type = value;
            }

            public String getCode() {
                return code;
            }

            public void setCode(String value) {
                this.code = value;
            }

            /**
             * Gets a map that contains attributes that aren't bound to any typed property on this class.
             * 
             * <p>
             * the map is keyed by the name of the attribute and 
             * the value is the string value of the attribute.
             * 
             * the map returned by this method is live, and you can add new attribute
             * by updating the map directly. Because of this design, there's no setter.
             * 
             * 
             * @return
             *     always non-null
             */
            public Map<QName, String> getOtherAttributes() {
                return otherAttributes;
            }

        }

        @XmlAccessorType(XmlAccessType.FIELD)
        @XmlType(name = "", propOrder = {
            "content"
        })
        public static class BarcodeImpl
            implements AddressDetails.PostalServiceElements.Barcode
        {

            @XmlValue
            protected String content;
            @XmlAttribute(name = "Type")
            @XmlSchemaType(name = "anySimpleType")
            protected String type;
            @XmlAttribute(name = "Code")
            @XmlSchemaType(name = "anySimpleType")
            protected String code;
            @XmlAnyAttribute
            private Map<QName, String> otherAttributes = new HashMap<QName, String>();

            public String getContent() {
                return content;
            }

            public void setContent(String value) {
                this.content = value;
            }

            public String getType() {
                return type;
            }

            public void setType(String value) {
                this.type = value;
            }

            public String getCode() {
                return code;
            }

            public void setCode(String value) {
                this.code = value;
            }

            /**
             * Gets a map that contains attributes that aren't bound to any typed property on this class.
             * 
             * <p>
             * the map is keyed by the name of the attribute and 
             * the value is the string value of the attribute.
             * 
             * the map returned by this method is live, and you can add new attribute
             * by updating the map directly. Because of this design, there's no setter.
             * 
             * 
             * @return
             *     always non-null
             */
            public Map<QName, String> getOtherAttributes() {
                return otherAttributes;
            }

        }

        @XmlAccessorType(XmlAccessType.FIELD)
        @XmlType(name = "", propOrder = {
            "content"
        })
        public static class EndorsementLineCodeImpl
            implements AddressDetails.PostalServiceElements.EndorsementLineCode
        {

            @XmlValue
            protected String content;
            @XmlAttribute(name = "Type")
            @XmlSchemaType(name = "anySimpleType")
            protected String type;
            @XmlAttribute(name = "Code")
            @XmlSchemaType(name = "anySimpleType")
            protected String code;
            @XmlAnyAttribute
            private Map<QName, String> otherAttributes = new HashMap<QName, String>();

            public String getContent() {
                return content;
            }

            public void setContent(String value) {
                this.content = value;
            }

            public String getType() {
                return type;
            }

            public void setType(String value) {
                this.type = value;
            }

            public String getCode() {
                return code;
            }

            public void setCode(String value) {
                this.code = value;
            }

            /**
             * Gets a map that contains attributes that aren't bound to any typed property on this class.
             * 
             * <p>
             * the map is keyed by the name of the attribute and 
             * the value is the string value of the attribute.
             * 
             * the map returned by this method is live, and you can add new attribute
             * by updating the map directly. Because of this design, there's no setter.
             * 
             * 
             * @return
             *     always non-null
             */
            public Map<QName, String> getOtherAttributes() {
                return otherAttributes;
            }

        }

        @XmlAccessorType(XmlAccessType.FIELD)
        @XmlType(name = "", propOrder = {
            "content"
        })
        public static class KeyLineCodeImpl
            implements AddressDetails.PostalServiceElements.KeyLineCode
        {

            @XmlValue
            protected String content;
            @XmlAttribute(name = "Type")
            @XmlSchemaType(name = "anySimpleType")
            protected String type;
            @XmlAttribute(name = "Code")
            @XmlSchemaType(name = "anySimpleType")
            protected String code;
            @XmlAnyAttribute
            private Map<QName, String> otherAttributes = new HashMap<QName, String>();

            public String getContent() {
                return content;
            }

            public void setContent(String value) {
                this.content = value;
            }

            public String getType() {
                return type;
            }

            public void setType(String value) {
                this.type = value;
            }

            public String getCode() {
                return code;
            }

            public void setCode(String value) {
                this.code = value;
            }

            /**
             * Gets a map that contains attributes that aren't bound to any typed property on this class.
             * 
             * <p>
             * the map is keyed by the name of the attribute and 
             * the value is the string value of the attribute.
             * 
             * the map returned by this method is live, and you can add new attribute
             * by updating the map directly. Because of this design, there's no setter.
             * 
             * 
             * @return
             *     always non-null
             */
            public Map<QName, String> getOtherAttributes() {
                return otherAttributes;
            }

        }

        @XmlAccessorType(XmlAccessType.FIELD)
        @XmlType(name = "")
        public static class SortingCodeImpl
            implements AddressDetails.PostalServiceElements.SortingCode
        {

            @XmlAttribute(name = "Type")
            @XmlSchemaType(name = "anySimpleType")
            protected String type;
            @XmlAttribute(name = "Code")
            @XmlSchemaType(name = "anySimpleType")
            protected String code;

            public String getType() {
                return type;
            }

            public void setType(String value) {
                this.type = value;
            }

            public String getCode() {
                return code;
            }

            public void setCode(String value) {
                this.code = value;
            }

        }

        @XmlAccessorType(XmlAccessType.FIELD)
        @XmlType(name = "", propOrder = {
            "content"
        })
        public static class SupplementaryPostalServiceDataImpl
            implements AddressDetails.PostalServiceElements.SupplementaryPostalServiceData
        {

            @XmlValue
            protected String content;
            @XmlAttribute(name = "Type")
            @XmlSchemaType(name = "anySimpleType")
            protected String type;
            @XmlAttribute(name = "Code")
            @XmlSchemaType(name = "anySimpleType")
            protected String code;
            @XmlAnyAttribute
            private Map<QName, String> otherAttributes = new HashMap<QName, String>();

            public String getContent() {
                return content;
            }

            public void setContent(String value) {
                this.content = value;
            }

            public String getType() {
                return type;
            }

            public void setType(String value) {
                this.type = value;
            }

            public String getCode() {
                return code;
            }

            public void setCode(String value) {
                this.code = value;
            }

            /**
             * Gets a map that contains attributes that aren't bound to any typed property on this class.
             * 
             * <p>
             * the map is keyed by the name of the attribute and 
             * the value is the string value of the attribute.
             * 
             * the map returned by this method is live, and you can add new attribute
             * by updating the map directly. Because of this design, there's no setter.
             * 
             * 
             * @return
             *     always non-null
             */
            public Map<QName, String> getOtherAttributes() {
                return otherAttributes;
            }

        }

    }

}
